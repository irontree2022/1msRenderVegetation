#pragma kernel Hi_z_Main


struct Bounds
{
    float3 center;
    float3 extents;
};


uint InstancesCount;
StructuredBuffer<float4x4> InstancesStructuredBuffer;
StructuredBuffer<Bounds> InstancesBoundsStructuredBuffer;


float4 FrustumPlanes[6];
float3 CameraPosition;



Texture2D<float> _HiZMap;
int rtMipmapCount;
int minMipmapLevel;
float4x4 vpMatrix; //相机的VP矩阵
int isOpenGL; //是否是OpenGL的API
int usesReversedZBuffer;




int EnableFrustumCulling;
int UseFrustumPlanes;
int EnabelHi_z_OcclusionCulling;
int ScreenWidth;
int ScreenHeight;


float nearClipPlane;
float farClipPlane;

int EnableDrawGrassInstanceBounds;
int onlyGetVisibleBoundsNearPoint;
float3 nearPoint;
float nearDistance;





AppendStructuredBuffer<float4x4> cullResultAppendBuffer; //剔除后保留的草
AppendStructuredBuffer<Bounds> cullResultBoundsAppendBuffer; //剔除后保留的草






bool IsOutsideThePlane(float4 plane, float3 pointPosition)
{
    return (dot(plane.xyz, pointPosition) + plane.w > 0);
}
bool IsCulled(in float4 boundVerts[8])
{
	//如果8个顶点都在某个面外，则肯定在视锥体外面
    for (int i = 0; i < 6; i++)
    {
        for (int j = 0; j < 8; j++)
        {
            if (!IsOutsideThePlane(FrustumPlanes[i], boundVerts[j].xyz))
                break;
            if (j == 7)
                return true;
        }
    }
    return false;
}
//在Clip Space下，根据齐次坐标做Clipping操作
bool IsInClipSpace(in float4 clipSpacePosition)
{
    if (isOpenGL != 0)
        return clipSpacePosition.x > -clipSpacePosition.w && clipSpacePosition.x < clipSpacePosition.w &&
        clipSpacePosition.y > -clipSpacePosition.w && clipSpacePosition.y < clipSpacePosition.w &&
        clipSpacePosition.z > -clipSpacePosition.w && clipSpacePosition.z < clipSpacePosition.w;
    else
        return clipSpacePosition.x > -clipSpacePosition.w && clipSpacePosition.x < clipSpacePosition.w &&
        clipSpacePosition.y > -clipSpacePosition.w && clipSpacePosition.y < clipSpacePosition.w &&
        clipSpacePosition.z > 0 && clipSpacePosition.z < clipSpacePosition.w;
}
// 计算遮挡关系
bool isOccluded(in float2 uv, in float depth, in int3 mipmapData)
{
    bool result = true;
    int2 ScreenSize = int2(ScreenWidth, ScreenHeight);
    // 先将uv映射到[0-1]之间，
    uv = uv * 0.5f + 0.5f;
    float2 pixel = uv * float2(ScreenSize.x, ScreenSize.y);

    bool isInScreen = pixel.x >= 0 || pixel.y >= 0 || pixel.x <= ScreenSize.x - 1 || pixel.y <= ScreenSize.y - 1;
    // 剔除屏幕之外的像素点
    if (isInScreen)
    {
        // 取对应mipmap上的像素值
        int2 mipmapSize = int2(mipmapData.x, mipmapData.y);
        int mipmapLevel = mipmapData.z;
        pixel = uv * mipmapSize;
        int pixelX = clamp((int) pixel.x, 0, mipmapSize.x - 1);
        int pixelY = clamp((int) pixel.y, 0, mipmapSize.y - 1);
        float pixelDepthValue = _HiZMap.Load(int3(pixelX, pixelY, mipmapLevel));
        // 深度大于深度图记录的深度，表示被遮挡住了
        result = depth > pixelDepthValue;
    }

    return result;
}





[numthreads(64,1,1)]
void Hi_z_Main(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= InstancesCount)
        return;
    
    float4x4 grassInstance = InstancesStructuredBuffer[id.x];
    // 这里记录了每个草实例的实际包围盒，
    // 但是如果没有旋转和缩放，那么包围盒只需要一直值就足够了，
    // 那样就可以在这里使用类似代码： grassBounds.center = mMatrix.GetPosition();
    // 将包围盒更新到当前实例的世界坐标处
    Bounds grassBounds = InstancesBoundsStructuredBuffer[id.x];
    
    
    //包围盒的8个顶点的View Space坐标
    float3 boundMin = grassBounds.center - grassBounds.extents;
    float3 boundMax = grassBounds.center + grassBounds.extents;
    float4 boundVerts[8];
    boundVerts[0] = float4(boundMin, 1);
    boundVerts[1] = float4(boundMax, 1);
    boundVerts[2] = float4(boundMax.x, boundMax.y, boundMin.z, 1);
    boundVerts[3] = float4(boundMax.x, boundMin.y, boundMax.z, 1);
    boundVerts[4] = float4(boundMax.x, boundMin.y, boundMin.z, 1);
    boundVerts[5] = float4(boundMin.x, boundMax.y, boundMax.z, 1);
    boundVerts[6] = float4(boundMin.x, boundMax.y, boundMin.z, 1);
    boundVerts[7] = float4(boundMin.x, boundMin.y, boundMax.z, 1);
    
    bool ndcDone = false;
    float minX = 1, minY = 1, minZ = 1, maxX = -1, maxY = -1, maxZ = -1; //NDC下新的的AABB各个参数
    
    
    //-------------------------------------------------------视椎剔除-------------------------------------------------------
    if (EnableFrustumCulling != 0)
    {
        if (UseFrustumPlanes != 0)
        {
            // 使用平截头六个面实现视锥剔除
            bool culled = IsCulled(boundVerts);
            if (culled)
                return;
        }
        else
        {
            // 裁剪空间实现视锥剔除：
            //      适用小物体，比如草；
            //      当物体非常大时，就不适用了，因为大包围盒可见，但它的顶点都在NDC之外，就会被错误剔除掉
            //
            // 通过mvp矩阵得到顶点的Clip Space的齐次坐标，然后在Clip Space做视椎剔除判断，所有点都不在NDC内就被剔除。
            bool isInClipSpace = false;
            for (int i = 0; i < 8; i++)
            {
                float4 clipSpace = mul(vpMatrix, boundVerts[i]);
                if (!isInClipSpace && IsInClipSpace(clipSpace))
                    isInClipSpace = true;

                if (EnabelHi_z_OcclusionCulling)
                {
                    //计算ndc下的新的AABB
                    float3 ndc = clipSpace.xyz / clipSpace.w;
                    if (minX > ndc.x)
                        minX = ndc.x;
                    if (minY > ndc.y)
                        minY = ndc.y;
                    if (minZ > ndc.z)
                        minZ = ndc.z;
                    if (maxX < ndc.x)
                        maxX = ndc.x;
                    if (maxY < ndc.y)
                        maxY = ndc.y;
                    if (maxZ < ndc.z)
                        maxZ = ndc.z;
                    ndcDone = true;
                }
            }

            if (!isInClipSpace)
                return;
        }
    }
    
    
    
     //-------------------------------------------------------遮挡剔除-------------------------------------------------------
    if (EnabelHi_z_OcclusionCulling != 0)
    {
        if (!ndcDone)
        {
            for (int i = 0; i < 8; i++)
            {
                float4 clipSpace = mul(vpMatrix, boundVerts[i]);
                //计算ndc下的新的AABB
                float3 ndc = clipSpace.xyz / clipSpace.w;
                if (minX > ndc.x)
                    minX = ndc.x;
                if (minY > ndc.y)
                    minY = ndc.y;
                if (minZ > ndc.z)
                    minZ = ndc.z;
                if (maxX < ndc.x)
                    maxX = ndc.x;
                if (maxY < ndc.y)
                    maxY = ndc.y;
                if (maxZ < ndc.z)
                    maxZ = ndc.z;
            }
        }
        
        
        // 求当前覆盖屏幕的像素尺寸，
        // 并根据最长的边，log2求出对应mipmapLevel
        float2 minUV = float2(minX, minY);
        float2 maxUV = float2(maxX, maxY);
        float2 minPixel = minUV * float2(ScreenWidth, ScreenHeight);
        float2 maxPixel = maxUV * float2(ScreenWidth, ScreenHeight); // 这里就计算出当前物体覆盖屏幕的像素区域
        float maxPixelCount = max(abs(maxPixel.x - minPixel.x), abs(maxPixel.y - minPixel.y)); // 物体覆盖屏幕像素区域的最长一边
        int mipmapLevel = clamp((int) log2(maxPixelCount), 0, min(rtMipmapCount - 1, minMipmapLevel)); // log2求出取值mipmap层级，clamp确保层级在最小和最大层级之间
        // 将宽、高和计算求得的要取值的mipmapLevel，一起传给 isOccluded() 函数计算遮挡关系
        int2 mipmapSize = int2(ScreenWidth >> mipmapLevel, ScreenHeight >> mipmapLevel);
        // 动态Mip层级选择，如果包围盒覆盖像素边长大于该Mip纹理尺寸，则选择更精细的Mip层级
        if (maxPixelCount > mipmapSize.x || maxPixelCount > mipmapSize.y)
        {
            mipmapLevel = clamp(mipmapLevel - 1, 0, mipmapLevel - 1);
            mipmapSize = int2(ScreenWidth >> mipmapLevel, ScreenHeight >> mipmapLevel);
        }
        int3 mipmapData = int3(mipmapSize, mipmapLevel);
                
        // 深度值映射到[0-1]之间
        // 优先取相机最近的深度值，OpenGL取最小z；
        // 其他平台默认是反转的，所以取最大z（再度反转后，就自然变成最小z了）
        float depth = minZ;
        if (isOpenGL != 0)
            depth = minZ * 0.5f + 0.5f; // OpenGL ndc.z处于[-1,1]之间，需要映射到[0-1]
        if (usesReversedZBuffer != 0)
        {
            depth = maxZ;
            depth = 1.0f - depth; // 处理平台差异：DX11/Metal/Vulkan 使用反向Z，1.0（近） → 0.0（远）
        }
         // 深度图中写入的是0-1的线性深度值，这里要同步处理成线性深度值
        float zBufferParamX = 1.0f - farClipPlane / nearClipPlane;
        float zBufferParamY = farClipPlane / nearClipPlane;
        float linear01Depth = 1.0f / (zBufferParamX * depth + zBufferParamY);
        
        // 保守剔除策略：新包围盒的四个顶点都被遮挡住了，才会被剔除
        float2 uv0 = float2(minX, minY);
        float2 uv1 = float2(minX, maxY);
        float2 uv2 = float2(maxX, minY);
        float2 uv3 = float2(maxX, maxY);
        if (isOccluded(uv0, linear01Depth, mipmapData) &&
            isOccluded(uv1, linear01Depth, mipmapData) &&
            isOccluded(uv2, linear01Depth, mipmapData) &&
            isOccluded(uv3, linear01Depth, mipmapData))
            return;
    }
    
    
    // ------------------------------------------------------剔除结果----------------------------------------------------
    cullResultAppendBuffer.Append(grassInstance);
    if (EnableDrawGrassInstanceBounds != 0 && (onlyGetVisibleBoundsNearPoint == 0 || (distance(nearPoint, grassBounds.center) <= nearDistance)))
        cullResultBoundsAppendBuffer.Append(grassBounds);
    
}
