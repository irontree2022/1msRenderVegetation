#pragma kernel CullVegetations

struct VegetationInstanceData {
	float3 center;
	float3 extents;
	float4x4 MatrixData;
	int InstanceID;
	int ModelPrototypeID;
};

struct Bounds {
	float3 center;
	float3 extents;
};


uint InstancesCount;
StructuredBuffer<VegetationInstanceData> InstancesStructuredBuffer;


int LODLevelsCount;
float4 LODLevels;
bool enableImpostor;
float tanHalfAngle;
float4 FrustumPlanes[6];
float3 CameraPosition;

// 添加四个参与LOD计算的参数
float QualitySettingsLodBias;
bool CameraOrthographic;
float CameraOrthographicSize;
float CameraFieldOfView;
float LODGroupSize;

float MaxCoreRenderingDistance;
float MaxRenderingDistance;
bool ShowVisibleVegetationBounds;


AppendStructuredBuffer<VegetationInstanceData> VisibleLOD0AppendStructuredBuffer;
AppendStructuredBuffer<VegetationInstanceData> VisibleLOD1AppendStructuredBuffer;
AppendStructuredBuffer<VegetationInstanceData> VisibleLOD2AppendStructuredBuffer;
AppendStructuredBuffer<VegetationInstanceData> VisibleLOD3AppendStructuredBuffer;
AppendStructuredBuffer<VegetationInstanceData> VisibleLOD4AppendStructuredBuffer;
AppendStructuredBuffer<Bounds> VegetationBoundsAppendStructuredBuffer;


// 阴影优化
bool EnableShadowOptimization;
float3 SunshineDir;
AppendStructuredBuffer<VegetationInstanceData> VisibleShadowAppendStructuredBuffer;


float Distance(float3 center, float3 min, float3 max)
{
	float x = center.x;
	float y = center.y;
	float z = center.z;
	if (x < min.x) x = min.x;
	else if (x > max.x) x = max.x;
	if (y < min.y) y = min.y;
	else if (y > max.y) y = max.y;
	if (z < min.z) z = min.z;
	else if (z > max.z) z = max.z;
	return abs(distance(float3(x, y, z), center));
}
bool IsInBounds(float3 center, float3 min, float3 max) {
	return center.x >= min.x && center.y >= min.y && center.z >= min.z && center.x <= max.x && center.y <= max.y && center.z <= max.z;
}
bool IsOutsideThePlane(float4 plane, float3 pointPosition)
{
	return (dot(plane.xyz, pointPosition) + plane.w > 0);
}
bool IsCulled(in float3 boundVerts[8])
{
	//如果8个顶点都在某个面外，则肯定在视锥体外面
	for (int i = 0; i < 6; i++) {
		for (int j = 0; j < 8; j++) {
			if (!IsOutsideThePlane(FrustumPlanes[i], boundVerts[j])) break;
			if (j == 7) return true;
		}
	}
	return false;
}
int CalculateLOD(float4x4 instanceMatrix, float3 boundsExtents)
{
	float dist = abs(distance(instanceMatrix._14_24_34, CameraPosition));
	float maxViewSize = max(max(boundsExtents.x, boundsExtents.y), boundsExtents.z) / (dist * tanHalfAngle);
	for (int i = 0; i < LODLevelsCount; i++)
	{
		float lodLevel = 0;
		if (i == 0) lodLevel = LODLevels.x;
		else if (i == 1) lodLevel = LODLevels.y;
		else if (i == 2) lodLevel = LODLevels.z;
		else if (i == 3) lodLevel = LODLevels.w;
		if (maxViewSize > lodLevel)
			return i;
	}
	return 4;
}
// 计算LOD对象的屏占比值
float GetRelativeHeight(
		float3 lodBoundsCenter, float3 cameraPos, float lodBias,
		bool CameraOrthographic, float CameraOrthographicSize, float CameraFieldOfView,
		float3 lodGroupLossyScale, float lodGroupSize)
{
    float3 scale = lodGroupLossyScale;
    float largestAxis = abs(scale.x);
    largestAxis = max(largestAxis, abs(scale.y));
    largestAxis = max(largestAxis, abs(scale.z));
    float size = lodGroupSize * largestAxis; // lod对象最大的尺寸

    if (CameraOrthographic)
		// 正交相机
		// 使用相机正交尺寸当作屏幕尺寸，计算屏占比
        return (size * 0.5F / CameraOrthographicSize) * lodBias;

	// 透视相机
	// 使用相似三角形，就算屏占比
    float dist = abs(distance(lodBoundsCenter, cameraPos));
    float halfAngle = tanHalfAngle;
    float relativeHeight = size * 0.5F / (dist * halfAngle);
    return relativeHeight * lodBias;
}
// 就LOD对象的LOD级别
int CalculateLOD(float3 lodBoundsCenter, float3 cameraPos, float lodBias,
		bool CameraOrthographic, float CameraOrthographicSize, float CameraFieldOfView,
		float3 lodGroupLossyScale, float lodGroupSize,
		int lodLevelsCount, float4 lodLevels)
{
	// 计算出LOD对象的屏占比值
    float currLOD = GetRelativeHeight(
                lodBoundsCenter,
                cameraPos,
                lodBias,
                CameraOrthographic, CameraOrthographicSize, CameraFieldOfView,
                lodGroupLossyScale, lodGroupSize);

	// 出LOD对象的LOD级别
    for (int i = 0; i < lodLevelsCount; i++)
    {
        if (i > 3)
            break;
        float lodLevel = 0;
        if (i == 0)
            lodLevel = lodLevels.x;
        else if (i == 1)
            lodLevel = lodLevels.y;
        else if (i == 2)
            lodLevel = lodLevels.z;
        else if (i == 3)
            lodLevel = lodLevels.w;
        if (currLOD >= lodLevel)
            return i;
    }
    return 4;
}

/// <summary>
/// 计算直线与平面的交点
/// </summary>
/// <param name="p">直线上某一点</param>
/// <param name="direct">直线的方向</param>
/// <param name="planeNormal">垂直于平面的的向量</param>
/// <param name="planePoint">平面上的任意一点</param>
/// <param name="result">交点</param>
/// <returns>是否相交</returns>
bool GetIntersectWithLineAndPlane(float3 p, float3 direct, float3 planeNormal, float3 planePoint, out float3 result)
{
	result = float3(0, 0, 0);
    //要注意直线和平面平行的情况
    float d1 = dot(direct, planeNormal);
    if (d1 == 0)
        return false;
    float d2 = dot(planePoint - p,
    planeNormal);
    float d3 = d2 / d1;

    result = d3 * direct + p;
    return true;
}

[numthreads(64, 1, 1)]
void CullVegetations(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= InstancesCount) return;
	VegetationInstanceData instance = InstancesStructuredBuffer[id.x];
	float3 boundMin = instance.center - instance.extents;
	float3 boundMax = instance.center + instance.extents;

	// 包围盒的八个点
	float3 boundVerts[8];
	boundVerts[0] = boundMin;
	boundVerts[1] = boundMax;
	boundVerts[2] = float3(boundMax.x, boundMax.y, boundMin.z);
	boundVerts[3] = float3(boundMax.x, boundMin.y, boundMax.z);
	boundVerts[4] = float3(boundMax.x, boundMin.y, boundMin.z);
	boundVerts[5] = float3(boundMin.x, boundMax.y, boundMax.z);
	boundVerts[6] = float3(boundMin.x, boundMax.y, boundMin.z);
	boundVerts[7] = float3(boundMin.x, boundMin.y, boundMax.z);

	// 测试植被可见性
	bool culled = IsCulled(boundVerts);
    if (culled)
    {
        if (EnableShadowOptimization)
        {
			// 重新计算阴影+原本植被包围盒的AABB包围盒
            float3 newBoundsMin = boundMin;
            float3 newBoundsMax = boundMax;
            // 假设地面法向量向上，地面的一点是原本植被包围盒最底部的其中一点，
            // 这里选择原本包围盒的最小点，也就是说这里假设植被最低点就是地面。
            float3 planeNormal = float3(0, 1, 0);
            float3 planePoint = boundMin;
            bool isIntersection = false;
            // 阳光从原本植被包围盒顶部的那四个顶点射向地面
            for (int i = 1; i < 8; i += 2)
            {
                float3 vert = boundVerts[i];
                 // result交点就是顶点投射到地面的阴影点，
                float3 result;
                if (GetIntersectWithLineAndPlane(vert, SunshineDir, planeNormal, planePoint, result))
                {
                    isIntersection = true;
                    // 重新计算包围盒最大最小点
                    if (result.x < newBoundsMin.x)
                        newBoundsMin.x = result.x;
                    if (result.y < newBoundsMin.y)
                        newBoundsMin.y = result.y;
                    if (result.z < newBoundsMin.z)
                        newBoundsMin.z = result.z;
                    if (result.x > newBoundsMax.x)
                        newBoundsMax.x = result.x;
                    if (result.y > newBoundsMax.y)
                        newBoundsMax.y = result.y;
                    if (result.z > newBoundsMax.z)
                        newBoundsMax.z = result.z;
                }
                else
                {
                    // 如果阳光与地面平行，则不存在阴影
                    isIntersection = false;
                    break;
                }
            }

            if (isIntersection)
            {
				// 使用新的包围盒进行视锥剔除，
				// 如果依旧不可见，则剔除这个植被
				// 如果可见，则说明当前植被实例虽然植被本身不可见，但它的阴影却是可见的。
                boundVerts[0] = newBoundsMin;
                boundVerts[1] = newBoundsMax;
                boundVerts[2] = float3(newBoundsMax.x, newBoundsMax.y, newBoundsMin.z);
                boundVerts[3] = float3(newBoundsMax.x, newBoundsMin.y, newBoundsMax.z);
                boundVerts[4] = float3(newBoundsMax.x, newBoundsMin.y, newBoundsMin.z);
                boundVerts[5] = float3(newBoundsMin.x, newBoundsMax.y, newBoundsMax.z);
                boundVerts[6] = float3(newBoundsMin.x, newBoundsMax.y, newBoundsMin.z);
                boundVerts[7] = float3(newBoundsMin.x, newBoundsMin.y, newBoundsMax.z);
                if (!IsCulled(boundVerts))
                {
					// 阴影可见时，将阴影植被数据存入仅渲染阴影的容器中
					// 这里还可以再次计算阴影的lod，用以渲染时选择合适的lod网格和材质球
					// 但计算了阴影lod之后，就需要对应容器写入....
                    VisibleShadowAppendStructuredBuffer.Append(instance);
                }
            }
			
            ////将被提出的全部都渲染阴影
            //VisibleShadowAppendStructuredBuffer.Append(instance);
        }
        return;
    }


	// 摄像机是否在当前区块内
	float isCameraInBlock = IsInBounds(CameraPosition, boundMin, boundMax);
	// 摄像机到当前实例的最近距离
	float cameraToInstanceDistance = isCameraInBlock ? 0 : Distance(CameraPosition, boundMin, boundMax);

	// 剔除超过最大渲染距离的植被
	if (!isCameraInBlock && cameraToInstanceDistance > MaxRenderingDistance)
		return;



	// 超出核心植被渲染距离的，渲染面片
	if (!isCameraInBlock && cameraToInstanceDistance > MaxCoreRenderingDistance)
	{
		if (enableImpostor)
		{
			VisibleLOD4AppendStructuredBuffer.Append(instance);
		
			if (ShowVisibleVegetationBounds)
			{
				Bounds bounds;
				bounds.center = instance.center;
				bounds.extents = instance.extents;
				VegetationBoundsAppendStructuredBuffer.Append(bounds);
			}
		}
		return;
	}

	// 计算lod
	int lod = 0;
	if (LODLevelsCount > 0)
    {
        float3 lossyScale = float3(length(instance.MatrixData._m00_m10_m20), length(instance.MatrixData._m01_m11_m21), length(instance.MatrixData._m02_m12_m22));
        lod = CalculateLOD(instance.center, CameraPosition, QualitySettingsLodBias, 
				CameraOrthographic, CameraOrthographicSize, CameraFieldOfView, 
				lossyScale, LODGroupSize, 
				LODLevelsCount, LODLevels);
    }
	if (lod == 0)
		VisibleLOD0AppendStructuredBuffer.Append(instance);
	else if (lod == 1)
		VisibleLOD1AppendStructuredBuffer.Append(instance);
	else if (lod == 2)
		VisibleLOD2AppendStructuredBuffer.Append(instance);
	else if (lod == 3)
		VisibleLOD3AppendStructuredBuffer.Append(instance);
	else if (lod == 4 && enableImpostor)
		VisibleLOD4AppendStructuredBuffer.Append(instance);
	
	if (ShowVisibleVegetationBounds)
	{
		Bounds bounds;
		bounds.center = instance.center;
		bounds.extents = instance.extents;
		VegetationBoundsAppendStructuredBuffer.Append(bounds);
	}
}
